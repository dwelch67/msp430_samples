
Derived from uart02.  LLVM says that msp430 is experimental and right
now it is tempermental, not producing working code.  So switching to
mspgcc.  The mspgcc4 project was so much nicer, all automated and it
just worked.  Getting mspgcc to work is harder, but I had some success
supposedly the new Ubuntu has mspgcc as a package, unfortunately the
new ubuntu user interface as well as the new gnome are unusable, time
to find a new distro.

See the top level README.tools.txt for info on getting/building mspgcc


So this uart03 example is derived from the uart02 example.  uart_putc
bit bangs the serial port to send characters out. and the main program
itself has a loop that is watching the input pin (p1.1) for a falling
edge indicating a start bit.  Then it counts out half a bit cell so that
in theory it is sampling mid bitcell for all the bits.  Basically how
a real uart works except they take more samples to try to detect mid
bit cell state changes and/or triple voting or other reasons.

Similar to the way that uart_putc shifts out the bits when finished
shifting in bit 0 is the start bit, bits 8:1 are the character and
bit 9 is the stop bit.  If bit 0 is not a 0 or bit 9 is not a 1 then
there is a framing error and assume the data is bad and discard.

This code, since it prints out what it found after character comes in
is not able to handle back to back charaters on the input, this code
is strictly to demonstrate how to use the timer to sample incoming
rs323 data.  The reverse of bit banging basically.
